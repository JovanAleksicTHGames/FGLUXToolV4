<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Miro Resource Calculator</title>
    <script src="https://miro.com/app/static/sdk/v2/miro.js?v=4"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 0;
            margin: 0;
            background: #f8f9fa;
            height: 100vh;
            overflow: hidden;
        }

        .container {
            max-width: 280px;
            height: 100vh;
            overflow-y: auto;
            padding: 15px;
            box-sizing: border-box;
        }

        h3 {
            margin: 0 0 15px 0;
            font-size: 16px;
            color: #333;
        }

        .section {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            margin-bottom: 12px;
            padding: 12px;
        }

        .section-title {
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 10px;
            color: #495057;
            border-bottom: 1px solid #e9ecef;
            padding-bottom: 5px;
        }

        .globals-grid {
            display: grid;
            grid-template-columns: 1fr 60px;
            gap: 8px;
            align-items: center;
        }

            .globals-grid label {
                font-size: 12px;
                font-weight: 500;
            }

            .globals-grid input {
                padding: 4px 6px;
                border: 1px solid #ced4da;
                border-radius: 3px;
                font-size: 11px;
                text-align: center;
            }

        button {
            width: 100%;
            padding: 8px;
            margin: 3px 0;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
        }

        .btn-sum {
            background: #ffc107;
            color: #000;
        }

        .btn-product {
            background: #28a745;
            color: white;
        }

        .btn-spawn {
            background: #6c757d;
            color: white;
        }

        .btn-expand {
            background: #17a2b8;
            color: white;
        }

        button:disabled {
            background: #e9ecef;
            color: #6c757d;
            cursor: not-allowed;
        }

        button:hover:not(:disabled) {
            opacity: 0.9;
        }

        #selection {
            padding: 8px;
            background: #f8f9fa;
            border-radius: 4px;
            margin-bottom: 8px;
            font-size: 11px;
            border: 1px solid #e9ecef;
        }

        .resource-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-bottom: 8px;
        }

        .resource-btn {
            padding: 6px;
            font-size: 11px;
            border-radius: 3px;
            border: 1px solid #dee2e6;
        }

        .barrel-small {
            background: #fff3cd;
            color: #856404;
        }

        .barrel-medium {
            background: #ffeaa7;
            color: #6c5400;
        }

        .barrel-big {
            background: #fdcb6e;
            color: #5a4a00;
        }

        .dig {
            background: #d4edda;
            color: #155724;
        }

        .crate {
            background: #d1ecf1;
            color: #0c5460;
        }

        .pool-controls {
            display: flex;
            gap: 4px;
            margin-bottom: 8px;
            flex-direction: column;
        }

        .pool-select, .pool-input, .spawn-input {
            padding: 6px;
            border: 1px solid #ced4da;
            border-radius: 3px;
            font-size: 11px;
            background: white;
        }

        .pool-input, .spawn-input {
            text-align: center;
        }

        .pool-btn {
            flex: 1;
            padding: 6px;
            font-size: 11px;
        }

        .pool-create {
            background: #007bff;
            color: white;
            border: 1px solid #007bff;
        }

        .relationships-section {
            margin-top: 15px;
        }

        .toggle-btn {
            width: 100%;
            padding: 8px;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            text-align: left;
        }

            .toggle-btn:hover {
                background: #e9ecef;
            }

        .relationships-list {
            border: 1px solid #dee2e6;
            border-top: none;
            border-radius: 0 0 4px 4px;
            max-height: 200px;
            overflow-y: auto;
            background: white;
        }

        .relationship-item {
            padding: 8px;
            margin: 4px;
            background: #f8f9fa;
            border-radius: 3px;
            border-left: 3px solid #007bff;
            font-size: 11px;
        }

            .relationship-item.sum {
                border-left-color: #ffc107;
            }

            .relationship-item.product {
                border-left-color: #28a745;
            }

        .relationship-header {
            font-weight: 600;
            margin-bottom: 4px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .relationship-name {
            font-size: 10px;
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 5px;
            cursor: pointer;
        }

        .relationship-sources {
            font-size: 10px;
            color: #666;
            margin-bottom: 4px;
        }

        .relationship-actions {
            display: flex;
            gap: 4px;
            margin-top: 6px;
        }

        .action-btn {
            flex: 1;
            font-size: 9px;
            padding: 3px 6px;
            margin: 0;
        }

        .goto-btn {
            background: #007bff;
            color: white;
        }

        .select-parents-btn {
            background: #28a745;
            color: white;
        }

        .rename-btn {
            background: #17a2b8;
            color: white;
        }

        .delete-btn {
            background: #dc3545;
            color: white;
        }

        #status {
            margin-top: 10px;
            padding: 8px;
            border-radius: 4px;
            display: none;
            font-size: 12px;
        }

        .success {
            background: #d4edda;
            color: #155724;
        }

        .error {
            background: #f8d7da;
            color: #721c24;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.4);
        }

        .modal-content {
            background: #fefefe;
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #888;
            border-radius: 6px;
            width: 250px;
            text-align: center;
        }

        .modal input {
            width: 100%;
            padding: 8px;
            margin: 10px 0;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
        }

        .modal button {
            margin: 5px;
            padding: 8px 16px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h3>Miro Resource Calculator</h3>

        <div class="section">
            <div class="section-title">Global Variables</div>
            <div class="globals-grid">
                <label>Barrel Small:</label>
                <input type="number" id="barrelSmall" value="5" min="1">
                <label>Barrel Medium:</label>
                <input type="number" id="barrelMedium" value="10" min="1">
                <label>Barrel Big:</label>
                <input type="number" id="barrelBig" value="20" min="1">
                <label>Dig:</label>
                <input type="number" id="digValue" value="3" min="1">
                <label>Crate:</label>
                <input type="number" id="crateValue" value="15" min="1">
            </div>
        </div>

        <div class="section">
            <div class="section-title">Calculator</div>
            <div id="selection">Select sticky notes with numbers</div>
            <button id="sumBtn" class="btn-sum" disabled>Create Sum</button>
            <button id="productBtn" class="btn-product" disabled>Create Product</button>
            <button id="expandBtn" class="btn-expand" disabled>Expand Relationship</button>
        </div>

        <div class="section">
            <div class="section-title">Create Resources</div>
            <div class="resource-controls">
                <button id="createBarrelSmall" class="resource-btn barrel-small">Small Barrel</button>
                <button id="createBarrelMedium" class="resource-btn barrel-medium">Med Barrel</button>
                <button id="createBarrelBig" class="resource-btn barrel-big">Big Barrel</button>
                <button id="createDig" class="resource-btn dig">Dig</button>
                <button id="createCrate" class="resource-btn crate">Crate</button>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Resource Pool Spawner</div>
            <div class="pool-controls">
                <select id="resourceTypeSelect" class="pool-select">
                    <option value="barrel-small">Small Barrel</option>
                    <option value="barrel-medium">Med Barrel</option>
                    <option value="barrel-big">Big Barrel</option>
                    <option value="dig">Dig</option>
                    <option value="crate">Crate</option>
                </select>
                <input type="number" id="poolQuantity" class="pool-input" min="2" max="20" value="3" placeholder="Quantity">
            </div>
            <button id="createResourcePool" class="pool-btn pool-create">Create Connected Pool</button>
        </div>

        <div class="section">
            <div class="section-title">Spawn Numbers</div>
            <input type="number" id="spawnCount" class="spawn-input" min="1" max="20" value="3" placeholder="Number to spawn">
            <button id="spawnBtn" class="btn-spawn">Spawn Connected Numbers</button>
        </div>

        <div class="relationships-section">
            <button id="toggleRelationships" class="toggle-btn">
                ▼ Show Relationships (<span id="relationshipCount">0</span>)
            </button>
            <div id="relationshipsList" class="relationships-list" style="display: none;">
                <div id="relationshipsContent">No calculator relationships found</div>
            </div>
        </div>

        <div id="status"></div>
    </div>

    <div id="renameModal" class="modal">
        <div class="modal-content">
            <h4>Rename Relationship</h4>
            <input type="text" id="renameInput" placeholder="Enter new name" maxlength="20">
            <div>
                <button id="confirmRename" class="btn-sum">Save</button>
                <button id="cancelRename" class="btn-spawn">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        //JavaScript goes here
        // Miro Resource Calculator App - SDK v2 Compatible
        // Global state management
        let appState = {
            relationships: new Map(),
            globalVars: {
                barrelSmall: 5,
                barrelMedium: 10,
                barrelBig: 20,
                dig: 3,
                crate: 15
            },
            isRelationshipsVisible: false
        };

        // App metadata keys for persistence
        const RELATIONSHIPS_KEY = 'calculatorRelationships';
        const GLOBAL_VARS_KEY = 'globalVariables';
        const APP_VERSION = '1.0.0';

        // Initialize the app when Miro SDK is ready
        async function initializeApp() {
            try {
                // Load persistent data
                await loadPersistedData();

                // Setup event handlers
                setupEventHandlers();

                // Setup Miro board event listeners
                await setupMiroEventListeners();

                // Update UI with loaded data
                updateGlobalVariablesUI();
                updateSelectionStatus();
                updateRelationshipsUI();

                console.log('Miro Resource Calculator initialized successfully');
                showStatus('App initialized successfully', 'success');

            } catch (error) {
                console.error('Failed to initialize app:', error);
                showStatus('Failed to initialize app: ' + error.message, 'error');
            }
        }

        // Load persisted data from Miro's storage
        async function loadPersistedData() {
            try {
                // Load global variables
                const savedGlobals = await miro.board.getAppData(GLOBAL_VARS_KEY);
                if (savedGlobals) {
                    appState.globalVars = { ...appState.globalVars, ...savedGlobals };
                }

                // Load relationships using storage collection for better scalability
                const relationshipsCollection = miro.board.storage.collection('relationships');
                const relationshipKeys = await relationshipsCollection.get('keys') || [];

                for (const key of relationshipKeys) {
                    const relationship = await relationshipsCollection.get(key);
                    if (relationship) {
                        appState.relationships.set(key, relationship);
                    }
                }

            } catch (error) {
                console.error('Error loading persisted data:', error);
            }
        }

        // Save data to Miro's storage
        async function saveData() {
            try {
                // Save global variables to app data
                await miro.board.setAppData(GLOBAL_VARS_KEY, appState.globalVars);

                // Save relationships to storage collection
                const relationshipsCollection = miro.board.storage.collection('relationships');
                const relationshipKeys = Array.from(appState.relationships.keys());

                // Store the list of keys
                await relationshipsCollection.set('keys', relationshipKeys);

                // Store each relationship
                for (const [key, relationship] of appState.relationships) {
                    await relationshipsCollection.set(key, relationship);
                }

            } catch (error) {
                console.error('Error saving data:', error);
                throw error;
            }
        }

        // Setup all event handlers for UI elements
        function setupEventHandlers() {
            // Global variables input handlers
            const globalInputs = ['barrelSmall', 'barrelMedium', 'barrelBig', 'digValue', 'crateValue'];
            globalInputs.forEach(inputId => {
                const input = document.getElementById(inputId);
                if (input) {
                    input.addEventListener('change', handleGlobalVariableChange);
                }
            });

            // Calculator button handlers
            document.getElementById('sumBtn')?.addEventListener('click', createSum);
            document.getElementById('productBtn')?.addEventListener('click', createProduct);
            document.getElementById('expandBtn')?.addEventListener('click', expandRelationship);

            // Resource creation handlers
            document.getElementById('createBarrelSmall')?.addEventListener('click', () => createResource('barrel-small'));
            document.getElementById('createBarrelMedium')?.addEventListener('click', () => createResource('barrel-medium'));
            document.getElementById('createBarrelBig')?.addEventListener('click', () => createResource('barrel-big'));
            document.getElementById('createDig')?.addEventListener('click', () => createResource('dig'));
            document.getElementById('createCrate')?.addEventListener('click', () => createResource('crate'));

            // Pool and spawn handlers
            document.getElementById('createResourcePool')?.addEventListener('click', createResourcePool);
            document.getElementById('spawnBtn')?.addEventListener('click', spawnNumbers);

            // Relationships panel handlers
            document.getElementById('toggleRelationships')?.addEventListener('click', toggleRelationships);

            // Modal handlers
            document.getElementById('confirmRename')?.addEventListener('click', confirmRename);
            document.getElementById('cancelRename')?.addEventListener('click', cancelRename);

            // Close modal when clicking outside
            document.getElementById('renameModal')?.addEventListener('click', (e) => {
                if (e.target.id === 'renameModal') {
                    cancelRename();
                }
            });
        }

        // Setup Miro board event listeners
        async function setupMiroEventListeners() {
            try {
                // Listen for selection changes
                await miro.board.ui.on('selection:update', handleSelectionChange);

                // Listen for item updates that might affect our relationships
                await miro.board.ui.on('experimental:items:update', handleItemsUpdate);

                // Listen for item deletion to clean up relationships
                await miro.board.ui.on('items:delete', handleItemsDelete);

            } catch (error) {
                console.error('Error setting up Miro event listeners:', error);
            }
        }

        // Handle selection changes on the board
        async function handleSelectionChange() {
            try {
                await updateSelectionStatus();
            } catch (error) {
                console.error('Error handling selection change:', error);
            }
        }

        // Handle item updates
        async function handleItemsUpdate(event) {
            try {
                // Check if any updated items are part of our relationships
                if (event.items) {
                    for (const item of event.items) {
                        await updateRelationshipsForItem(item.id);
                    }
                }
                await updateRelationshipsUI();
            } catch (error) {
                console.error('Error handling items update:', error);
            }
        }

        // Handle item deletion
        async function handleItemsDelete(event) {
            try {
                if (event.items) {
                    for (const item of event.items) {
                        await cleanupRelationshipsForItem(item.id);
                    }
                }
                await updateRelationshipsUI();
                await saveData();
            } catch (error) {
                console.error('Error handling items delete:', error);
            }
        }

        // Handle global variable changes
        async function handleGlobalVariableChange(event) {
            const inputId = event.target.id;
            const value = parseInt(event.target.value) || 1;

            const mapping = {
                'barrelSmall': 'barrelSmall',
                'barrelMedium': 'barrelMedium',
                'barrelBig': 'barrelBig',
                'digValue': 'dig',
                'crateValue': 'crate'
            };

            if (mapping[inputId]) {
                appState.globalVars[mapping[inputId]] = value;
                await saveData();
                showStatus('Global variables updated', 'success');
            }
        }

        // Update the global variables UI with current values
        function updateGlobalVariablesUI() {
            document.getElementById('barrelSmall').value = appState.globalVars.barrelSmall;
            document.getElementById('barrelMedium').value = appState.globalVars.barrelMedium;
            document.getElementById('barrelBig').value = appState.globalVars.barrelBig;
            document.getElementById('digValue').value = appState.globalVars.dig;
            document.getElementById('crateValue').value = appState.globalVars.crate;
        }

        // Update selection status and enable/disable buttons
        async function updateSelectionStatus() {
            try {
                const selection = await miro.board.getSelection();
                const validItems = selection.filter(item =>
                    item.type === 'sticky_note' && hasNumericContent(item.content)
                );

                const count = validItems.length;
                const hasValidSelection = count >= 2;

                // Update selection display
                const selectionDiv = document.getElementById('selection');
                if (selectionDiv) {
                    if (count === 0) {
                        selectionDiv.textContent = 'Select sticky notes with numbers';
                    } else if (count === 1) {
                        selectionDiv.textContent = `1 numeric sticky note selected (need 2+)`;
                    } else {
                        selectionDiv.textContent = `${count} numeric sticky notes selected`;
                    }
                }

                // Enable/disable buttons
                document.getElementById('sumBtn').disabled = !hasValidSelection;
                document.getElementById('productBtn').disabled = !hasValidSelection;
                document.getElementById('expandBtn').disabled = count !== 1 || !isResultNote(validItems[0]);

            } catch (error) {
                console.error('Error updating selection status:', error);
            }
        }

        // Extract numeric value from content
        function extractNumericValue(content) {
            if (!content) return null;

            // Look for numbers in parentheses first: "Small Barrel (10)"
            const parenMatch = content.match(/\((\d+(?:\.\d+)?)\)/);
            if (parenMatch) {
                return parseFloat(parenMatch[1]);
            }

            // Look for standalone numbers
            const numberMatch = content.match(/(\d+(?:\.\d+)?)/);
            if (numberMatch) {
                return parseFloat(numberMatch[1]);
            }

            return null;
        }

        // Check if content has numeric value
        function hasNumericContent(content) {
            return extractNumericValue(content) !== null;
        }

        // Check if a sticky note is a result from our calculator
        function isResultNote(item) {
            if (!item.content) return false;
            return item.content.includes('Sum:') || item.content.includes('Product:');
        }

        // Create sum calculation
        async function createSum() {
            try {
                const selection = await miro.board.getSelection();
                const validItems = selection.filter(item =>
                    item.type === 'sticky_note' && hasNumericContent(item.content)
                );

                if (validItems.length < 2) {
                    showStatus('Select at least 2 sticky notes with numbers', 'error');
                    return;
                }

                const values = validItems.map(item => extractNumericValue(item.content));
                const sum = values.reduce((acc, val) => acc + val, 0);

                // Calculate position for result note
                const avgX = validItems.reduce((acc, item) => acc + item.x, 0) / validItems.length;
                const avgY = validItems.reduce((acc, item) => acc + item.y, 0) / validItems.length;

                // Create result sticky note
                const resultNote = await miro.board.createStickyNote({
                    content: `Sum: ${sum}`,
                    x: avgX,
                    y: avgY - 100,
                    style: {
                        fillColor: '#ffc107',
                        textAlign: 'center'
                    }
                });

                // Create relationship
                const relationshipId = generateRelationshipId();
                const relationship = {
                    id: relationshipId,
                    type: 'sum',
                    name: `Sum ${relationshipId.slice(-6)}`,
                    result: resultNote.id,
                    sources: validItems.map(item => item.id),
                    values: values,
                    resultValue: sum,
                    createdAt: Date.now()
                };

                appState.relationships.set(relationshipId, relationship);

                // Store relationship metadata in result note
                await resultNote.setMetadata('calculatorRelationship', relationshipId);

                await saveData();
                await updateRelationshipsUI();

                showStatus(`Sum created: ${sum}`, 'success');

            } catch (error) {
                console.error('Error creating sum:', error);
                showStatus('Error creating sum: ' + error.message, 'error');
            }
        }

        // Create product calculation
        async function createProduct() {
            try {
                const selection = await miro.board.getSelection();
                const validItems = selection.filter(item =>
                    item.type === 'sticky_note' && hasNumericContent(item.content)
                );

                if (validItems.length < 2) {
                    showStatus('Select at least 2 sticky notes with numbers', 'error');
                    return;
                }

                const values = validItems.map(item => extractNumericValue(item.content));
                const product = values.reduce((acc, val) => acc * val, 1);

                // Calculate position for result note
                const avgX = validItems.reduce((acc, item) => acc + item.x, 0) / validItems.length;
                const avgY = validItems.reduce((acc, item) => acc + item.y, 0) / validItems.length;

                // Create result sticky note
                const resultNote = await miro.board.createStickyNote({
                    content: `Product: ${product}`,
                    x: avgX,
                    y: avgY - 100,
                    style: {
                        fillColor: '#28a745',
                        textAlign: 'center'
                    }
                });

                // Create relationship
                const relationshipId = generateRelationshipId();
                const relationship = {
                    id: relationshipId,
                    type: 'product',
                    name: `Product ${relationshipId.slice(-6)}`,
                    result: resultNote.id,
                    sources: validItems.map(item => item.id),
                    values: values,
                    resultValue: product,
                    createdAt: Date.now()
                };

                appState.relationships.set(relationshipId, relationship);

                // Store relationship metadata in result note
                await resultNote.setMetadata('calculatorRelationship', relationshipId);

                await saveData();
                await updateRelationshipsUI();

                showStatus(`Product created: ${product}`, 'success');

            } catch (error) {
                console.error('Error creating product:', error);
                showStatus('Error creating product: ' + error.message, 'error');
            }
        }

        // Expand relationship (show sources)
        async function expandRelationship() {
            try {
                const selection = await miro.board.getSelection();
                if (selection.length !== 1) {
                    showStatus('Select exactly one result note', 'error');
                    return;
                }

                const selectedItem = selection[0];
                const relationshipId = await selectedItem.getMetadata('calculatorRelationship');

                if (!relationshipId || !appState.relationships.has(relationshipId)) {
                    showStatus('Selected note is not a calculator result', 'error');
                    return;
                }

                const relationship = appState.relationships.get(relationshipId);
                const sourceIds = [...relationship.sources, relationship.result];

                // Select all related items
                await miro.board.select({ id: sourceIds });

                // Focus viewport on the items
                const items = [];
                for (const id of sourceIds) {
                    try {
                        const item = await miro.board.getById(id);
                        items.push(item);
                    } catch (e) {
                        console.log('Item not found:', id);
                    }
                }

                if (items.length > 0) {
                    await miro.board.viewport.zoomTo(items);
                }

                showStatus('Relationship expanded', 'success');

            } catch (error) {
                console.error('Error expanding relationship:', error);
                showStatus('Error expanding relationship: ' + error.message, 'error');
            }
        }

        // Create resource sticky note
        async function createResource(resourceType) {
            try {
                const resourceValues = {
                    'barrel-small': { value: appState.globalVars.barrelSmall, name: 'Small Barrel', color: '#fff3cd' },
                    'barrel-medium': { value: appState.globalVars.barrelMedium, name: 'Med Barrel', color: '#ffeaa7' },
                    'barrel-big': { value: appState.globalVars.barrelBig, name: 'Big Barrel', color: '#fdcb6e' },
                    'dig': { value: appState.globalVars.dig, name: 'Dig', color: '#d4edda' },
                    'crate': { value: appState.globalVars.crate, name: 'Crate', color: '#d1ecf1' }
                };

                const resource = resourceValues[resourceType];
                if (!resource) return;

                const viewport = await miro.board.viewport.get();
                const centerX = viewport.x + viewport.width / 2;
                const centerY = viewport.y + viewport.height / 2;

                await miro.board.createStickyNote({
                    content: `${resource.name} (${resource.value})`,
                    x: centerX + (Math.random() - 0.5) * 200,
                    y: centerY + (Math.random() - 0.5) * 200,
                    style: {
                        fillColor: resource.color,
                        textAlign: 'center'
                    }
                });

                showStatus(`${resource.name} created`, 'success');

            } catch (error) {
                console.error('Error creating resource:', error);
                showStatus('Error creating resource: ' + error.message, 'error');
            }
        }

        // Create resource pool
        async function createResourcePool() {
            try {
                const resourceType = document.getElementById('resourceTypeSelect').value;
                const quantity = parseInt(document.getElementById('poolQuantity').value) || 3;

                if (quantity < 2 || quantity > 20) {
                    showStatus('Quantity must be between 2 and 20', 'error');
                    return;
                }

                const resourceValues = {
                    'barrel-small': { value: appState.globalVars.barrelSmall, name: 'Small Barrel', color: '#fff3cd' },
                    'barrel-medium': { value: appState.globalVars.barrelMedium, name: 'Med Barrel', color: '#ffeaa7' },
                    'barrel-big': { value: appState.globalVars.barrelBig, name: 'Big Barrel', color: '#fdcb6e' },
                    'dig': { value: appState.globalVars.dig, name: 'Dig', color: '#d4edda' },
                    'crate': { value: appState.globalVars.crate, name: 'Crate', color: '#d1ecf1' }
                };

                const resource = resourceValues[resourceType];
                if (!resource) return;

                const viewport = await miro.board.viewport.get();
                const centerX = viewport.x + viewport.width / 2;
                const centerY = viewport.y + viewport.height / 2;

                const notes = [];
                const spacing = 120;
                const cols = Math.ceil(Math.sqrt(quantity));

                for (let i = 0; i < quantity; i++) {
                    const row = Math.floor(i / cols);
                    const col = i % cols;
                    const x = centerX + (col - (cols - 1) / 2) * spacing;
                    const y = centerY + (row - Math.floor((quantity - 1) / cols) / 2) * spacing;

                    const note = await miro.board.createStickyNote({
                        content: `${resource.name} (${resource.value})`,
                        x: x,
                        y: y,
                        style: {
                            fillColor: resource.color,
                            textAlign: 'center'
                        }
                    });

                    notes.push(note);
                }

                // Create connectors between notes
                for (let i = 0; i < notes.length - 1; i++) {
                    await miro.board.createConnector({
                        start: { item: notes[i].id },
                        end: { item: notes[i + 1].id },
                        style: { strokeColor: '#666' }
                    });
                }

                showStatus(`Resource pool of ${quantity} ${resource.name}s created`, 'success');

            } catch (error) {
                console.error('Error creating resource pool:', error);
                showStatus('Error creating resource pool: ' + error.message, 'error');
            }
        }

        // Spawn connected numbers
        async function spawnNumbers() {
            try {
                const count = parseInt(document.getElementById('spawnCount').value) || 3;

                if (count < 1 || count > 20) {
                    showStatus('Count must be between 1 and 20', 'error');
                    return;
                }

                const viewport = await miro.board.viewport.get();
                const centerX = viewport.x + viewport.width / 2;
                const centerY = viewport.y + viewport.height / 2;

                const notes = [];
                const spacing = 100;

                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * 2 * Math.PI;
                    const x = centerX + Math.cos(angle) * spacing;
                    const y = centerY + Math.sin(angle) * spacing;

                    const note = await miro.board.createStickyNote({
                        content: (i + 1).toString(),
                        x: x,
                        y: y,
                        style: {
                            fillColor: '#f8f9fa',
                            textAlign: 'center'
                        }
                    });

                    notes.push(note);
                }

                // Create connectors between consecutive notes
                for (let i = 0; i < notes.length; i++) {
                    const nextIndex = (i + 1) % notes.length;
                    await miro.board.createConnector({
                        start: { item: notes[i].id },
                        end: { item: notes[nextIndex].id },
                        style: { strokeColor: '#666' }
                    });
                }

                showStatus(`${count} connected numbers spawned`, 'success');

            } catch (error) {
                console.error('Error spawning numbers:', error);
                showStatus('Error spawning numbers: ' + error.message, 'error');
            }
        }

        // Toggle relationships panel visibility
        function toggleRelationships() {
            appState.isRelationshipsVisible = !appState.isRelationshipsVisible;
            const relationshipsList = document.getElementById('relationshipsList');
            const toggleBtn = document.getElementById('toggleRelationships');

            if (appState.isRelationshipsVisible) {
                relationshipsList.style.display = 'block';
                toggleBtn.textContent = toggleBtn.textContent.replace('▼', '▲');
            } else {
                relationshipsList.style.display = 'none';
                toggleBtn.textContent = toggleBtn.textContent.replace('▲', '▼');
            }
        }

        // Update relationships UI
        async function updateRelationshipsUI() {
            const count = appState.relationships.size;
            document.getElementById('relationshipCount').textContent = count;

            const content = document.getElementById('relationshipsContent');

            if (count === 0) {
                content.innerHTML = 'No calculator relationships found';
                return;
            }

            const relationships = Array.from(appState.relationships.values())
                .sort((a, b) => b.createdAt - a.createdAt);

            content.innerHTML = relationships.map(rel => `
        <div class="relationship-item ${rel.type}">
            <div class="relationship-header" onclick="gotoRelationship('${rel.id}')">
                <span>${rel.type === 'sum' ? 'Sum' : 'Product'}: ${rel.resultValue}</span>
                <span class="relationship-name" onclick="event.stopPropagation(); renameRelationship('${rel.id}')">${rel.name}</span>
            </div>
            <div class="relationship-sources">Sources: ${rel.values.join(' + ')}</div>
            <div class="relationship-actions">
                <button class="action-btn goto-btn" onclick="gotoRelationship('${rel.id}')">Go To</button>
                <button class="action-btn select-parents-btn" onclick="selectParents('${rel.id}')">Select Parents</button>
                <button class="action-btn rename-btn" onclick="renameRelationship('${rel.id}')">Rename</button>
                <button class="action-btn delete-btn" onclick="deleteRelationship('${rel.id}')">Delete</button>
            </div>
        </div>
    `).join('');
        }

        // Go to relationship items
        async function gotoRelationship(relationshipId) {
            try {
                const relationship = appState.relationships.get(relationshipId);
                if (!relationship) return;

                const allIds = [...relationship.sources, relationship.result];
                const items = [];

                for (const id of allIds) {
                    try {
                        const item = await miro.board.getById(id);
                        items.push(item);
                    } catch (e) {
                        console.log('Item not found:', id);
                    }
                }

                if (items.length > 0) {
                    await miro.board.select({ id: items.map(item => item.id) });
                    await miro.board.viewport.zoomTo(items);
                }

            } catch (error) {
                console.error('Error going to relationship:', error);
                showStatus('Error navigating to relationship', 'error');
            }
        }

        // Select parent items only
        async function selectParents(relationshipId) {
            try {
                const relationship = appState.relationships.get(relationshipId);
                if (!relationship) return;

                const items = [];
                for (const id of relationship.sources) {
                    try {
                        const item = await miro.board.getById(id);
                        items.push(item);
                    } catch (e) {
                        console.log('Item not found:', id);
                    }
                }

                if (items.length > 0) {
                    await miro.board.select({ id: items.map(item => item.id) });
                    await miro.board.viewport.zoomTo(items);
                }

            } catch (error) {
                console.error('Error selecting parents:', error);
                showStatus('Error selecting parent items', 'error');
            }
        }

        // Rename relationship
        let currentRenameId = null;

        function renameRelationship(relationshipId) {
            const relationship = appState.relationships.get(relationshipId);
            if (!relationship) return;

            currentRenameId = relationshipId;
            document.getElementById('renameInput').value = relationship.name;
            document.getElementById('renameModal').style.display = 'block';
            document.getElementById('renameInput').focus();
        }

        async function confirmRename() {
            if (!currentRenameId) return;

            const newName = document.getElementById('renameInput').value.trim();
            if (!newName) {
                showStatus('Name cannot be empty', 'error');
                return;
            }

            const relationship = appState.relationships.get(currentRenameId);
            if (relationship) {
                relationship.name = newName;
                await saveData();
                await updateRelationshipsUI();
                showStatus('Relationship renamed', 'success');
            }

            cancelRename();
        }

        function cancelRename() {
            currentRenameId = null;
            document.getElementById('renameModal').style.display = 'none';
            document.getElementById('renameInput').value = '';
        }

        // Delete relationship
        async function deleteRelationship(relationshipId) {
            try {
                const relationship = appState.relationships.get(relationshipId);
                if (!relationship) return;

                if (!confirm(`Delete relationship "${relationship.name}"?`)) return;

                // Remove relationship
                appState.relationships.delete(relationshipId);

                // Clean up metadata from result note
                try {
                    const resultItem = await miro.board.getById(relationship.result);
                    await resultItem.setMetadata('calculatorRelationship', null);
                } catch (e) {
                    console.log('Result item not found or already deleted');
                }

                await saveData();
                await updateRelationshipsUI();
                showStatus('Relationship deleted', 'success');

            } catch (error) {
                console.error('Error deleting relationship:', error);
                showStatus('Error deleting relationship', 'error');
            }
        }

        // Utility functions
        function generateRelationshipId() {
            return `rel_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        }

        async function updateRelationshipsForItem(itemId) {
            // Check if this item is part of any relationships and update if needed
            for (const [id, relationship] of appState.relationships) {
                if (relationship.sources.includes(itemId) || relationship.result === itemId) {
                    try {
                        const item = await miro.board.getById(itemId);
                        // Update relationship data if needed
                        if (relationship.result === itemId && item.content) {
                            // Update result value if result note content changed
                            const match = item.content.match(/(Sum|Product): ([\d.]+)/);
                            if (match) {
                                relationship.resultValue = parseFloat(match[2]);
                            }
                        }
                    } catch (e) {
                        console.log('Item not found during update:', itemId);
                    }
                }
            }
        }

        async function cleanupRelationshipsForItem(itemId) {
            // Remove relationships that reference deleted items
            const toDelete = [];

            for (const [id, relationship] of appState.relationships) {
                if (relationship.sources.includes(itemId) || relationship.result === itemId) {
                    toDelete.push(id);
                }
            }

            for (const id of toDelete) {
                appState.relationships.delete(id);
            }
        }

        // Show status message
        function showStatus(message, type = 'success') {
            const statusDiv = document.getElementById('status');
            if (!statusDiv) return;

            statusDiv.textContent = message;
            statusDiv.className = type;
            statusDiv.style.display = 'block';

            setTimeout(() => {
                statusDiv.style.display = 'none';
            }, 3000);
        }

        // Handle keyboard events
        document.addEventListener('keydown', (e) => {
            // Handle Enter key in rename modal
            if (e.key === 'Enter' && currentRenameId && document.getElementById('renameModal').style.display === 'block') {
                e.preventDefault();
                confirmRename();
            }

            // Handle Escape key to close modal
            if (e.key === 'Escape' && currentRenameId) {
                e.preventDefault();
                cancelRename();
            }
        });

        // Make functions globally accessible for onclick handlers
        window.gotoRelationship = gotoRelationship;
        window.selectParents = selectParents;
        window.renameRelationship = renameRelationship;
        window.deleteRelationship = deleteRelationship;

        // Auto-save functionality
        let saveTimeout;
        function scheduleAutoSave() {
            if (saveTimeout) clearTimeout(saveTimeout);
            saveTimeout = setTimeout(async () => {
                try {
                    await saveData();
                } catch (error) {
                    console.error('Auto-save failed:', error);
                }
            }, 2000);
        }

        // Data validation and cleanup
        async function validateAndCleanData() {
            const toDelete = [];

            for (const [id, relationship] of appState.relationships) {
                let isValid = true;

                // Check if result item still exists
                try {
                    await miro.board.getById(relationship.result);
                } catch (e) {
                    isValid = false;
                }

                // Check if source items still exist
                for (const sourceId of relationship.sources) {
                    try {
                        await miro.board.getById(sourceId);
                    } catch (e) {
                        isValid = false;
                        break;
                    }
                }

                if (!isValid) {
                    toDelete.push(id);
                }
            }

            // Remove invalid relationships
            for (const id of toDelete) {
                appState.relationships.delete(id);
            }

            if (toDelete.length > 0) {
                await saveData();
                await updateRelationshipsUI();
                showStatus(`Cleaned up ${toDelete.length} invalid relationship(s)`, 'success');
            }
        }

        // Periodic data validation (run every 30 seconds)
        setInterval(validateAndCleanData, 30000);

        // Export data functionality for debugging
        async function exportData() {
            const data = {
                version: APP_VERSION,
                globalVars: appState.globalVars,
                relationships: Object.fromEntries(appState.relationships),
                timestamp: Date.now()
            };

            console.log('Exported data:', data);

            // Copy to clipboard if available
            if (navigator.clipboard) {
                try {
                    await navigator.clipboard.writeText(JSON.stringify(data, null, 2));
                    showStatus('Data exported to clipboard', 'success');
                } catch (e) {
                    showStatus('Data exported to console', 'success');
                }
            } else {
                showStatus('Data exported to console', 'success');
            }
        }

        // Import data functionality for debugging
        async function importData(jsonData) {
            try {
                const data = typeof jsonData === 'string' ? JSON.parse(jsonData) : jsonData;

                if (data.globalVars) {
                    appState.globalVars = { ...appState.globalVars, ...data.globalVars };
                    updateGlobalVariablesUI();
                }

                if (data.relationships) {
                    appState.relationships = new Map(Object.entries(data.relationships));
                }

                await saveData();
                await updateRelationshipsUI();
                showStatus('Data imported successfully', 'success');

            } catch (error) {
                console.error('Import failed:', error);
                showStatus('Import failed: ' + error.message, 'error');
            }
        }

        // Debug functions (available in console)
        window.debugMiroCalculator = {
            exportData,
            importData,
            getState: () => appState,
            validateData: validateAndCleanData,
            clearAllData: async () => {
                if (confirm('Clear all calculator data? This cannot be undone.')) {
                    appState.relationships.clear();
                    await miro.board.setAppData(RELATIONSHIPS_KEY, null);
                    const relationshipsCollection = miro.board.storage.collection('relationships');
                    await relationshipsCollection.set('keys', []);
                    await updateRelationshipsUI();
                    showStatus('All data cleared', 'success');
                }
            }
        };

        // Error handling for unhandled promises
        window.addEventListener('unhandledrejection', (event) => {
            console.error('Unhandled promise rejection:', event.reason);
            showStatus('An unexpected error occurred', 'error');
        });

        // Initialize app when DOM is ready and Miro SDK is available
        async function startApp() {
            try {
                // Wait for DOM to be ready
                await waitForDOM();

                // Check if Miro SDK is available
                if (!window.miro) {
                    throw new Error('Miro SDK not available');
                }

                // Initialize the app
                await initializeApp();

            } catch (error) {
                console.error('Failed to start app:', error);
                const statusDiv = document.getElementById('status');
                if (statusDiv) {
                    statusDiv.textContent = 'Failed to start app: ' + error.message;
                    statusDiv.className = 'error';
                    statusDiv.style.display = 'block';
                }
            }
        }

        // Start the app
        startApp();
    </script>
</body>
</html>
