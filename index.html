<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Miro Resource Calculator</title>
    <script src="https://miro.com/app/static/sdk/v2/miro.js?v=4"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 0;
            margin: 0;
            background: #f8f9fa;
            height: 100vh;
            overflow: hidden;
        }

        .container {
            max-width: 280px;
            height: 100vh;
            overflow-y: auto;
            padding: 15px;
            box-sizing: border-box;
        }

        h3 {
            margin: 0 0 15px 0;
            font-size: 16px;
            color: #333;
        }

        .section {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            margin-bottom: 12px;
            padding: 12px;
        }

        .section-title {
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 10px;
            color: #495057;
            border-bottom: 1px solid #e9ecef;
            padding-bottom: 5px;
        }

        .globals-grid {
            display: grid;
            grid-template-columns: 1fr 60px;
            gap: 8px;
            align-items: center;
        }

            .globals-grid label {
                font-size: 12px;
                font-weight: 500;
            }

            .globals-grid input {
                padding: 4px 6px;
                border: 1px solid #ced4da;
                border-radius: 3px;
                font-size: 11px;
                text-align: center;
            }

        button {
            width: 100%;
            padding: 8px;
            margin: 3px 0;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
        }

        .btn-sum {
            background: #ffc107;
            color: #000;
        }

        .btn-product {
            background: #28a745;
            color: white;
        }

        .btn-spawn {
            background: #6c757d;
            color: white;
        }

        .btn-expand {
            background: #17a2b8;
            color: white;
        }

        button:disabled {
            background: #e9ecef;
            color: #6c757d;
            cursor: not-allowed;
        }

        button:hover:not(:disabled) {
            opacity: 0.9;
        }

        #selection {
            padding: 8px;
            background: #f8f9fa;
            border-radius: 4px;
            margin-bottom: 8px;
            font-size: 11px;
            border: 1px solid #e9ecef;
        }

        .resource-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-bottom: 8px;
        }

        .resource-btn {
            padding: 6px;
            font-size: 11px;
            border-radius: 3px;
            border: 1px solid #dee2e6;
        }

        .barrel-small {
            background: #fff3cd;
            color: #856404;
        }

        .barrel-medium {
            background: #ffeaa7;
            color: #6c5400;
        }

        .barrel-big {
            background: #fdcb6e;
            color: #5a4a00;
        }

        .dig {
            background: #d4edda;
            color: #155724;
        }

        .crate {
            background: #d1ecf1;
            color: #0c5460;
        }

        .pool-controls {
            display: flex;
            gap: 4px;
            margin-bottom: 8px;
            flex-direction: column;
        }

        .pool-select, .pool-input, .spawn-input {
            padding: 6px;
            border: 1px solid #ced4da;
            border-radius: 3px;
            font-size: 11px;
            background: white;
        }

        .pool-input, .spawn-input {
            text-align: center;
        }

        .pool-btn {
            flex: 1;
            padding: 6px;
            font-size: 11px;
        }

        .pool-create {
            background: #007bff;
            color: white;
            border: 1px solid #007bff;
        }

        .relationships-section {
            margin-top: 15px;
        }

        .toggle-btn {
            width: 100%;
            padding: 8px;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            text-align: left;
        }

            .toggle-btn:hover {
                background: #e9ecef;
            }

        .relationships-list {
            border: 1px solid #dee2e6;
            border-top: none;
            border-radius: 0 0 4px 4px;
            max-height: 200px;
            overflow-y: auto;
            background: white;
        }

        .relationship-item {
            padding: 8px;
            margin: 4px;
            background: #f8f9fa;
            border-radius: 3px;
            border-left: 3px solid #007bff;
            font-size: 11px;
        }

            .relationship-item.sum {
                border-left-color: #ffc107;
            }

            .relationship-item.product {
                border-left-color: #28a745;
            }

        .relationship-header {
            font-weight: 600;
            margin-bottom: 4px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .relationship-name {
            font-size: 10px;
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 5px;
            cursor: pointer;
        }

        .relationship-sources {
            font-size: 10px;
            color: #666;
            margin-bottom: 4px;
        }

        .relationship-actions {
            display: flex;
            gap: 4px;
            margin-top: 6px;
        }

        .action-btn {
            flex: 1;
            font-size: 9px;
            padding: 3px 6px;
            margin: 0;
        }

        .goto-btn {
            background: #007bff;
            color: white;
        }

        .select-parents-btn {
            background: #28a745;
            color: white;
        }

        .rename-btn {
            background: #17a2b8;
            color: white;
        }

        .delete-btn {
            background: #dc3545;
            color: white;
        }

        #status {
            margin-top: 10px;
            padding: 8px;
            border-radius: 4px;
            display: none;
            font-size: 12px;
        }

        .success {
            background: #d4edda;
            color: #155724;
        }

        .error {
            background: #f8d7da;
            color: #721c24;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.4);
        }

        .modal-content {
            background-color: #fefefe;
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #888;
            border-radius: 6px;
            width: 250px;
            text-align: center;
        }

        .modal input {
            width: 100%;
            padding: 8px;
            margin: 10px 0;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
        }

        .modal button {
            margin: 5px;
            padding: 8px 16px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h3>Miro Resource Calculator</h3>

        <div class="section">
            <div class="section-title">Global Variables</div>
            <div class="globals-grid">
                <label>Barrel Small:</label>
                <input type="number" id="barrelSmall" value="5" min="1">
                <label>Barrel Medium:</label>
                <input type="number" id="barrelMedium" value="10" min="1">
                <label>Barrel Big:</label>
                <input type="number" id="barrelBig" value="20" min="1">
                <label>Dig:</label>
                <input type="number" id="digValue" value="3" min="1">
                <label>Crate:</label>
                <input type="number" id="crateValue" value="15" min="1">
            </div>
        </div>

        <div class="section">
            <div class="section-title">Calculator</div>
            <div id="selection">Select sticky notes with numbers</div>
            <button id="sumBtn" class="btn-sum" disabled>Create Sum</button>
            <button id="productBtn" class="btn-product" disabled>Create Product</button>
            <button id="expandBtn" class="btn-expand" disabled>Expand Relationship</button>
        </div>

        <div class="section">
            <div class="section-title">Create Resources</div>
            <div class="resource-controls">
                <button id="createBarrelSmall" class="resource-btn barrel-small">Small Barrel</button>
                <button id="createBarrelMedium" class="resource-btn barrel-medium">Med Barrel</button>
                <button id="createBarrelBig" class="resource-btn barrel-big">Big Barrel</button>
                <button id="createDig" class="resource-btn dig">Dig</button>
                <button id="createCrate" class="resource-btn crate">Crate</button>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Resource Pool Spawner</div>
            <div class="pool-controls">
                <select id="resourceTypeSelect" class="pool-select">
                    <option value="barrel-small">Small Barrel</option>
                    <option value="barrel-medium">Med Barrel</option>
                    <option value="barrel-big">Big Barrel</option>
                    <option value="dig">Dig</option>
                    <option value="crate">Crate</option>
                </select>
                <input type="number" id="poolQuantity" class="pool-input" min="2" max="20" value="3" placeholder="Quantity">
            </div>
            <button id="createResourcePool" class="pool-btn pool-create">Create Connected Pool</button>
        </div>

        <div class="section">
            <div class="section-title">Spawn Numbers</div>
            <input type="number" id="spawnCount" class="spawn-input" min="1" max="20" value="3" placeholder="Number to spawn">
            <button id="spawnBtn" class="btn-spawn">Spawn Connected Numbers</button>
        </div>

        <div class="relationships-section">
            <button id="toggleRelationships" class="toggle-btn">
                ▼ Show Relationships (<span id="relationshipCount">0</span>)
            </button>
            <div id="relationshipsList" class="relationships-list" style="display: none;">
                <div id="relationshipsContent">No calculator relationships found</div>
            </div>
        </div>

        <div id="status"></div>
    </div>

    <div id="renameModal" class="modal">
        <div class="modal-content">
            <h4>Rename Relationship</h4>
            <input type="text" id="renameInput" placeholder="Enter new name" maxlength="20">
            <div>
                <button id="confirmRename" class="btn-sum">Save</button>
                <button id="cancelRename" class="btn-spawn">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // The complete JavaScript code goes here, as provided in the previous snippets.
        // Miro Resource Calculator App - SDK v2 Compatible
        // Fixed version with proper expand relationship functionality
        console.log('Miro Resource Calculator v2.2 - Loading...', new Date().toISOString());

        // Global state management
        let appState = {
            relationships: new Map(),
            globalVars: {
                barrelSmall: 5,
                barrelMedium: 10,
                barrelBig: 20,
                dig: 3,
                crate: 15
            },
            isRelationshipsVisible: false,
            initialized: false,
            updateThrottles: new Map(),
            intervals: new Set(),
            timeouts: new Set(),
            expandMode: null // Track if we're in expand mode
        };

        // App metadata keys for persistence
        const RELATIONSHIPS_KEY = 'calculatorRelationships';
        const GLOBAL_VARS_KEY = 'globalVariables';
        const APP_VERSION = '2.2.0';
        const DEPLOYMENT_ID = Date.now();
        const UPDATE_THROTTLE_DELAY = 500;
        console.log('Deployment ID:', DEPLOYMENT_ID);

        // Throttled update system for dynamic recalculation
        function throttleUpdate(key, callback, immediate = false) {
            if (appState.updateThrottles.has(key)) {
                clearTimeout(appState.updateThrottles.get(key));
            }

            if (immediate) {
                callback();
                return;
            }

            const timeoutId = setTimeout(() => {
                callback();
                appState.updateThrottles.delete(key);
            }, UPDATE_THROTTLE_DELAY);

            appState.updateThrottles.set(key, timeoutId);
            appState.timeouts.add(timeoutId);
        }

        // Clean up all throttled updates
        function cleanupThrottles() {
            for (const timeoutId of appState.updateThrottles.values()) {
                clearTimeout(timeoutId);
            }
            appState.updateThrottles.clear();
        }

        // Memory cleanup function
        function cleanupMemory() {
            console.log('Cleaning up memory...');
            cleanupThrottles();

            for (const intervalId of appState.intervals) {
                clearInterval(intervalId);
            }
            appState.intervals.clear();

            for (const timeoutId of appState.timeouts) {
                clearTimeout(timeoutId);
            }
            appState.timeouts.clear();

            console.log('Memory cleanup completed');
        }

        // Utility: Wait for DOM to be ready
        function waitForDOM() {
            return new Promise((resolve) => {
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', resolve);
                } else {
                    resolve(null);
                }
            });
        }

        // Utility: Safely get DOM element
        function safeGetElement(id, required = false) {
            const element = document.getElementById(id);
            if (!element) {
                const message = `Element '${id}' not found`;
                if (required) {
                    console.error(message);
                } else {
                    console.warn(message);
                }
            }
            return element;
        }

        // Load persisted data from Miro's storage
        async function loadPersistedData() {
            try {
                console.log('Loading persisted data...');

                const savedGlobals = await miro.board.getAppData(GLOBAL_VARS_KEY);
                if (savedGlobals) {
                    appState.globalVars = { ...appState.globalVars, ...savedGlobals };
                    console.log('Loaded global variables:', appState.globalVars);
                }

                const relationshipsCollection = miro.board.storage.collection('relationships');
                const relationshipKeys = await relationshipsCollection.get('keys') || [];

                for (const key of relationshipKeys) {
                    const relationship = await relationshipsCollection.get(key);
                    if (relationship) {
                        appState.relationships.set(key, relationship);
                    }
                }

                console.log(`Loaded ${appState.relationships.size} relationships`);

            } catch (error) {
                console.error('Error loading persisted data:', error);
            }
        }

        // Save data to Miro's storage
        async function saveData() {
            try {
                await miro.board.setAppData(GLOBAL_VARS_KEY, appState.globalVars);

                const relationshipsCollection = miro.board.storage.collection('relationships');
                const relationshipKeys = Array.from(appState.relationships.keys());

                await relationshipsCollection.set('keys', relationshipKeys);

                for (const [key, relationship] of appState.relationships) {
                    await relationshipsCollection.set(key, relationship);
                }

            } catch (error) {
                console.error('Error saving data:', error);
                throw error;
            }
        }

        // Update existing resource sticky notes when global variables change
        async function updateExistingResourceNotes(resourceType, oldValue, newValue) {
            try {
                console.log('Updating existing notes for:', resourceType, oldValue, '->', newValue);

                const allItems = await miro.board.get({ type: 'sticky_note' });

                const resourceNames = {
                    'barrelSmall': 'Small Barrel',
                    'barrelMedium': 'Med Barrel',
                    'barrelBig': 'Big Barrel',
                    'dig': 'Dig',
                    'crate': 'Crate'
                };

                const resourceName = resourceNames[resourceType];
                if (!resourceName) return;

                let updatedCount = 0;

                for (const item of allItems) {
                    if (item.content && item.content.includes(`${resourceName} (${oldValue})`)) {
                        const newContent = item.content.replace(`${resourceName} (${oldValue})`, `${resourceName} (${newValue})`);
                        item.content = newContent;
                        await item.sync();
                        updatedCount++;

                        console.log('Updated note:', item.id, newContent);
                    }
                }

                if (updatedCount > 0) {
                    console.log('Updated', updatedCount, 'existing notes for', resourceName);
                }

            } catch (error) {
                console.error('Error updating existing notes:', error);
            }
        }

        // Handle global variable changes
        async function handleGlobalVariableChange(event) {
            const inputId = event.target.id;
            const value = parseInt(event.target.value) || 1;

            const mapping = {
                'barrelSmall': 'barrelSmall',
                'barrelMedium': 'barrelMedium',
                'barrelBig': 'barrelBig',
                'digValue': 'dig',
                'crateValue': 'crate'
            };

            if (mapping[inputId]) {
                const oldValue = appState.globalVars[mapping[inputId]];
                appState.globalVars[mapping[inputId]] = value;

                await updateExistingResourceNotes(mapping[inputId], oldValue, value);

                console.log('Checking all relationships for updates after global variable change...');
                await checkAllRelationshipsForUpdates();

                await saveData();
                showStatus('Global variables updated and existing notes refreshed', 'success');
                console.log('Updated global variable and existing notes:', inputId, '=', value);
            }
        }

        // Check all relationships for updates (used after global variable changes)
        async function checkAllRelationshipsForUpdates() {
            console.log('Checking all relationships for potential updates...');

            for (const [relationshipId, relationship] of appState.relationships) {
                console.log('Immediately checking relationship:', relationshipId);
                throttleUpdate(relationshipId, () => recalculateRelationship(relationshipId), true);
            }

            console.log(`Immediately triggered ${appState.relationships.size} relationship recalculations`);
        }

        // Manual function to force update all relationships (for debugging)
        async function forceUpdateAllRelationships() {
            console.log('FORCE UPDATE: Manually triggering all relationship updates...');

            for (const [relationshipId, relationship] of appState.relationships) {
                console.log('Force updating relationship:', relationshipId);
                await recalculateRelationship(relationshipId);
            }

            console.log('Force update completed');
        }

        // Dynamic recalculation for relationships
        async function recalculateRelationship(relationshipId) {
            try {
                const relationship = appState.relationships.get(relationshipId);
                if (!relationship) {
                    console.warn('Relationship not found for recalculation:', relationshipId);
                    return;
                }

                console.log('Recalculating relationship:', relationshipId, 'type:', relationship.type);

                const currentValues = [];
                let allSourcesValid = true;
                const sourceContents = [];

                for (const sourceId of relationship.sources) {
                    try {
                        const sourceItem = await miro.board.getById(sourceId);
                        const value = extractNumericValue(sourceItem.content);

                        sourceContents.push(sourceItem.content);

                        if (value === null) {
                            console.warn('Source item has no valid numeric value:', sourceId, 'content:', sourceItem.content);
                            allSourcesValid = false;
                            break;
                        }

                        currentValues.push(value);
                        console.log('Source', sourceId, 'value:', value, 'content:', sourceItem.content);
                    } catch (e) {
                        console.warn('Source item was deleted:', sourceId);
                        allSourcesValid = false;
                        break;
                    }
                }

                if (!allSourcesValid) {
                    console.log('Some sources invalid, cleaning up relationship:', relationshipId);
                    await cleanupRelationshipsForItem(relationship.result);
                    await updateRelationshipsUI();
                    await saveData();
                    return;
                }

                let newResult;
                if (relationship.type === 'sum') {
                    newResult = currentValues.reduce((acc, val) => acc + val, 0);
                } else if (relationship.type === 'product') {
                    newResult = currentValues.reduce((acc, val) => acc * val, 1);
                } else {
                    console.warn('Unknown relationship type:', relationship.type);
                    return;
                }

                console.log('Calculated new result:', newResult, 'old result:', relationship.resultValue);

                if (Math.abs(newResult - relationship.resultValue) > 0.001) {
                    try {
                        const resultItem = await miro.board.getById(relationship.result);
                        const newContent = `${relationship.type === 'sum' ? 'Sum' : 'Product'}: ${newResult}`;

                        console.log('Updating result note content from:', resultItem.content, 'to:', newContent);

                        resultItem.content = newContent;
                        await resultItem.sync();

                        relationship.values = currentValues;
                        relationship.resultValue = newResult;
                        relationship.lastUpdated = Date.now();

                        await saveData();
                        await updateRelationshipsUI();

                        console.log('Successfully updated relationship result:', relationshipId, 'new value:', newResult);
                        showStatus(`${relationship.type} updated: ${newResult}`, 'success');

                    } catch (e) {
                        console.warn('Result item deleted, cleaning up relationship:', relationshipId, e);
                        await cleanupRelationshipsForItem(relationship.result);
                        await updateRelationshipsUI();
                        await saveData();
                    }
                } else {
                    console.log('No significant change in result, skipping update');
                }

            } catch (error) {
                console.error('Error recalculating relationship:', relationshipId, error);
            }
        }

        // Extract numeric value from content
        function extractNumericValue(content) {
            if (!content || typeof content !== 'string') return null;

            const cleanContent = content.trim();
            if (!cleanContent) return null;

            const parenMatch = cleanContent.match(/\((\d+(?:\.\d+)?)\)/);
            if (parenMatch) {
                const value = parseFloat(parenMatch[1]);
                return isNaN(value) ? null : value;
            }

            const resultMatch = cleanContent.match(/(?:Sum|Product):\s*(\d+(?:\.\d+)?)/i);
            if (resultMatch) {
                const value = parseFloat(resultMatch[1]);
                return isNaN(value) ? null : value;
            }

            const numberMatch = cleanContent.match(/^(\d+(?:\.\d+)?)(?:\s|$)/);
            if (numberMatch) {
                const value = parseFloat(numberMatch[1]);
                return isNaN(value) ? null : value;
            }

            const anyNumberMatch = cleanContent.match(/(\d+(?:\.\d+)?)/);
            if (anyNumberMatch) {
                const value = parseFloat(anyNumberMatch[1]);
                return isNaN(value) ? null : value;
            }

            return null;
        }

        // Check if content has numeric value
        function hasNumericContent(content) {
            return extractNumericValue(content) !== null;
        }

        // Check if a sticky note is a result from our calculator
        function isResultNote(item) {
            if (!item || !item.content) return false;
            return item.content.includes('Sum:') || item.content.includes('Product:');
        }

        // Setup all event handlers for UI elements
        function setupEventHandlers() {
            console.log('Setting up event handlers...');

            const globalInputs = [
                'barrelSmall', 'barrelMedium', 'barrelBig', 'digValue', 'crateValue'
            ];

            globalInputs.forEach(inputId => {
                const input = safeGetElement(inputId);
                if (input) {
                    input.addEventListener('change', handleGlobalVariableChange);
                    console.log('Added change listener to:', inputId);
                }
            });

            const calculatorButtons = [
                { id: 'sumBtn', handler: createSum, name: 'Sum' },
                { id: 'productBtn', handler: createProduct, name: 'Product' },
                { id: 'expandBtn', handler: expandRelationship, name: 'Expand' }
            ];

            calculatorButtons.forEach(({ id, handler, name }) => {
                const button = safeGetElement(id);
                if (button) {
                    button.addEventListener('click', handler);
                    console.log('Added click listener to:', name, 'button');
                }
            });

            const resourceButtons = [
                { id: 'createBarrelSmall', resource: 'barrel-small', name: 'Small Barrel' },
                { id: 'createBarrelMedium', resource: 'barrel-medium', name: 'Med Barrel' },
                { id: 'createBarrelBig', resource: 'barrel-big', name: 'Big Barrel' },
                { id: 'createDig', resource: 'dig', name: 'Dig' },
                { id: 'createCrate', resource: 'crate', name: 'Crate' }
            ];

            resourceButtons.forEach(({ id, resource, name }) => {
                const button = safeGetElement(id);
                if (button) {
                    const handler = function () { createResource(resource); };
                    button.addEventListener('click', handler);
                    console.log('Added click listener to:', name, 'resource button');
                }
            });

            const poolBtn = safeGetElement('createResourcePool');
            if (poolBtn) {
                poolBtn.addEventListener('click', createResourcePool);
                console.log('Added click listener to: Resource Pool button');
            }

            const spawnBtn = safeGetElement('spawnBtn');
            if (spawnBtn) {
                spawnBtn.addEventListener('click', spawnNumbers);
                console.log('Added click listener to: Spawn button');
            }

            const toggleBtn = safeGetElement('toggleRelationships');
            if (toggleBtn) {
                toggleBtn.addEventListener('click', toggleRelationships);
                console.log('Added click listener to: Toggle Relationships button');
            }

            const confirmBtn = safeGetElement('confirmRename');
            if (confirmBtn) {
                confirmBtn.addEventListener('click', confirmRename);
                console.log('Added click listener to: Confirm Rename button');
            }

            const cancelBtn = safeGetElement('cancelRename');
            if (cancelBtn) {
                cancelBtn.addEventListener('click', cancelRename);
                console.log('Added click listener to: Cancel Rename button');
            }

            const modal = safeGetElement('renameModal');
            if (modal) {
                const modalHandler = function (e) {
                    if (e.target.id === 'renameModal') {
                        cancelRename();
                    }
                };
                modal.addEventListener('click', modalHandler);
                console.log('Added click listener to: Rename Modal');
            }

            console.log('Event handlers setup complete');
        }

        // Setup Miro board event listeners
        async function setupMiroEventListeners() {
            try {
                console.log('Setting up Miro event listeners...');

                await miro.board.ui.on('icon:click', async () => {
                    console.log('App icon clicked - opening panel...');
                    await miro.board.ui.openPanel({
                        url: window.location.href
                    });
                });
                console.log('Registered icon:click listener');

                await miro.board.ui.on('selection:update', handleSelectionChange);
                console.log('Registered selection:update listener');

                try {
                    await miro.board.ui.on('experimental:items:update', handleItemsUpdate);
                    console.log('Registered experimental:items:update listener');
                } catch (e) {
                    console.warn('experimental:items:update not available:', e.message);
                }

                try {
                    await miro.board.ui.on('items:update', handleItemsUpdate);
                    console.log('Registered items:update listener');
                } catch (e) {
                    console.warn('items:update not available:', e.message);
                }

                await miro.board.ui.on('items:delete', handleItemsDelete);
                console.log('Registered items:delete listener');

                const updateCheckInterval = setInterval(checkForUpdates, 2000);
                appState.intervals.add(updateCheckInterval);
                console.log('Started periodic update check (2s interval)');

                console.log('Miro event listeners setup complete');

            } catch (error) {
                console.error('Error setting up Miro event listeners:', error);
                throw error;
            }
        }

        // Handle selection changes on the board
        async function handleSelectionChange() {
            try {
                await updateSelectionStatus();

                // Handle expand mode selection
                if (appState.expandMode) {
                    await handleExpandModeSelection();
                }
            } catch (error) {
                console.error('Error handling selection change:', error);
            }
        }

        // Handle expand mode selection
        async function handleExpandModeSelection() {
            try {
                const selection = await miro.board.getSelection();
                const validItems = selection.filter(item =>
                    item.type === 'sticky_note' && hasNumericContent(item.content) && !isResultNote(item)
                );

                if (validItems.length > 0) {
                    console.log('Adding', validItems.length, 'items to relationship in expand mode');
                    await addItemsToRelationship(appState.expandMode.relationshipId, validItems);
                }
            } catch (error) {
                console.error('Error handling expand mode selection:', error);
            }
        }

        // Add items to existing relationship
        async function addItemsToRelationship(relationshipId, newItems) {
            try {
                const relationship = appState.relationships.get(relationshipId);
                if (!relationship) {
                    console.error('Relationship not found:', relationshipId);
                    return;
                }

                const newSourceIds = newItems.map(item => item.id);
                const existingSourceIds = relationship.sources;

                // Filter out items that are already in the relationship
                const uniqueNewSourceIds = newSourceIds.filter(id => !existingSourceIds.includes(id));

                if (uniqueNewSourceIds.length === 0) {
                    showStatus('Selected items are already in this relationship', 'error');
                    return;
                }

                // Add new sources to the relationship
                relationship.sources = [...existingSourceIds, ...uniqueNewSourceIds];

                // Recalculate immediately
                await recalculateRelationship(relationshipId);

                showStatus(`Added ${uniqueNewSourceIds.length} items to ${relationship.name}`, 'success');
                console.log('Added items to relationship:', uniqueNewSourceIds);

            } catch (error) {
                console.error('Error adding items to relationship:', error);
                showStatus('Error adding items to relationship', 'error');
            }
        }

        // Handle item updates - triggers dynamic recalculation
        async function handleItemsUpdate(event) {
            try {
                console.log('Items update event received:', event);

                if (event.items) {
                    for (const item of event.items) {
                        const affectedRelationships = [];

                        for (const [relationshipId, relationship] of appState.relationships) {
                            if (relationship.sources.includes(item.id)) {
                                affectedRelationships.push(relationshipId);
                            }
                        }

                        console.log(`Item ${item.id} affects ${affectedRelationships.length} relationships`);

                        for (const relationshipId of affectedRelationships) {
                            throttleUpdate(relationshipId, () => recalculateRelationship(relationshipId));
                        }
                    }
                }
            } catch (error) {
                console.error('Error handling items update:', error);
            }
        }

        // Periodic check for updates as fallback when events don't work
        async function checkForUpdates() {
            try {
                if (appState.relationships.size === 0) return;

                for (const [relationshipId, relationship] of appState.relationships) {
                    let needsUpdate = false;
                    const currentValues = [];
                    const sourceDetails = [];

                    for (const sourceId of relationship.sources) {
                        try {
                            const sourceItem = await miro.board.getById(sourceId);
                            const currentValue = extractNumericValue(sourceItem.content);

                            sourceDetails.push({
                                id: sourceId,
                                content: sourceItem.content,
                                value: currentValue
                            });

                            if (currentValue === null) {
                                console.warn('Source item lost numeric value:', sourceId, sourceItem.content);
                                needsUpdate = true;
                                break;
                            }

                            currentValues.push(currentValue);
                        } catch (e) {
                            console.warn('Source item was deleted:', sourceId);
                            needsUpdate = true;
                            break;
                        }
                    }

                    if (!needsUpdate && currentValues.length === relationship.values.length) {
                        for (let i = 0; i < currentValues.length; i++) {
                            if (Math.abs(currentValues[i] - relationship.values[i]) > 0.001) {
                                console.log('Detected value change in relationship:', relationshipId);
                                console.log('Old values:', relationship.values);
                                console.log('New values:', currentValues);
                                console.log('Source details:', sourceDetails);
                                needsUpdate = true;
                                break;
                            }
                        }
                    } else if (!needsUpdate) {
                        console.log('Value array length changed for relationship:', relationshipId);
                        needsUpdate = true;
                    }

                    if (needsUpdate) {
                        console.log('Triggering recalculation for relationship:', relationshipId);
                        throttleUpdate(relationshipId, () => recalculateRelationship(relationshipId));
                    }
                }
            } catch (error) {
                console.error('Error in periodic update check:', error);
            }
        }

        // Handle item deletion
        async function handleItemsDelete(event) {
            try {
                if (event.items) {
                    for (const item of event.items) {
                        await cleanupRelationshipsForItem(item.id);
                    }
                }
                await updateRelationshipsUI();
                await saveData();
            } catch (error) {
                console.error('Error handling items delete:', error);
            }
        }

        // Update the global variables UI with current values
        function updateGlobalVariablesUI() {
            const updates = [
                { id: 'barrelSmall', value: appState.globalVars.barrelSmall },
                { id: 'barrelMedium', value: appState.globalVars.barrelMedium },
                { id: 'barrelBig', value: appState.globalVars.barrelBig },
                { id: 'digValue', value: appState.globalVars.dig },
                { id: 'crateValue', value: appState.globalVars.crate }
            ];

            updates.forEach(({ id, value }) => {
                const element = safeGetElement(id);
                if (element) {
                    element.value = value;
                }
            });

            console.log('Updated global variables UI');
        }

        // Update selection status and enable/disable buttons
        async function updateSelectionStatus() {
            try {
                const selection = await miro.board.getSelection();
                const validItems = selection.filter(item =>
                    item.type === 'sticky_note' && hasNumericContent(item.content)
                );

                const count = validItems.length;
                const hasValidSelection = count >= 2;

                const selectionDiv = safeGetElement('selection');
                if (selectionDiv) {
                    if (appState.expandMode) {
                        selectionDiv.textContent = `EXPAND MODE: Select items to add to ${appState.expandMode.relationshipName} (Click Expand again to exit)`;
                    } else if (count === 0) {
                        selectionDiv.textContent = 'Select sticky notes with numbers';
                    } else if (count === 1) {
                        selectionDiv.textContent = `1 numeric sticky note selected (need 2+)`;
                    } else {
                        selectionDiv.textContent = `${count} numeric sticky notes selected`;
                    }
                }

                const sumBtn = safeGetElement('sumBtn');
                const productBtn = safeGetElement('productBtn');
                const expandBtn = safeGetElement('expandBtn');

                if (sumBtn) sumBtn.disabled = !hasValidSelection || appState.expandMode;
                if (productBtn) productBtn.disabled = !hasValidSelection || appState.expandMode;
                if (expandBtn) {
                    if (appState.expandMode) {
                        expandBtn.disabled = false;
                        expandBtn.textContent = 'Exit Expand Mode';
                        expandBtn.style.backgroundColor = '#dc3545';
                    } else {
                        expandBtn.disabled = count !== 1 || !isResultNote(validItems[0]);
                        expandBtn.textContent = 'Expand Relationship';
                        expandBtn.style.backgroundColor = '#17a2b8';
                    }
                }

            } catch (error) {
                console.error('Error updating selection status:', error);
            }
        }

        // Create sum calculation
        async function createSum() {
            try {
                console.log('Creating sum calculation...');

                const selection = await miro.board.getSelection();
                const validItems = selection.filter(item =>
                    item.type === 'sticky_note' && hasNumericContent(item.content)
                );

                if (validItems.length < 2) {
                    showStatus('Select at least 2 sticky notes with numbers', 'error');
                    return;
                }

                const values = validItems.map(item => extractNumericValue(item.content));
                const sum = values.reduce((acc, val) => acc + val, 0);

                const avgX = validItems.reduce((acc, item) => acc + item.x, 0) / validItems.length;
                const avgY = validItems.reduce((acc, item) => acc + item.y, 0) / validItems.length;

                const resultNote = await miro.board.createStickyNote({
                    content: `Sum: ${sum}`,
                    x: avgX,
                    y: avgY - 100,
                    style: {
                        fillColor: 'yellow',
                        textAlign: 'center'
                    }
                });

                const relationshipId = generateRelationshipId();
                const relationship = {
                    id: relationshipId,
                    type: 'sum',
                    name: `Sum ${relationshipId.slice(-6)}`,
                    result: resultNote.id,
                    sources: validItems.map(item => item.id),
                    values: values,
                    resultValue: sum,
                    createdAt: Date.now()
                };

                appState.relationships.set(relationshipId, relationship);

                await resultNote.setMetadata('calculatorRelationship', relationshipId);

                await saveData();
                await updateRelationshipsUI();

                showStatus(`Sum created: ${sum}`, 'success');
                console.log('Sum calculation created:', sum);

            } catch (error) {
                console.error('Error creating sum:', error);
                showStatus('Error creating sum: ' + error.message, 'error');
            }
        }

        // Create product calculation
        async function createProduct() {
            try {
                console.log('Creating product calculation...');

                const selection = await miro.board.getSelection();
                const validItems = selection.filter(item =>
                    item.type === 'sticky_note' && hasNumericContent(item.content)
                );

                if (validItems.length < 2) {
                    showStatus('Select at least 2 sticky notes with numbers', 'error');
                    return;
                }

                const values = validItems.map(item => extractNumericValue(item.content));
                const product = values.reduce((acc, val) => acc * val, 1);

                const avgX = validItems.reduce((acc, item) => acc + item.x, 0) / validItems.length;
                const avgY = validItems.reduce((acc, item) => acc + item.y, 0) / validItems.length;

                const resultNote = await miro.board.createStickyNote({
                    content: `Product: ${product}`,
                    x: avgX,
                    y: avgY - 100,
                    style: {
                        fillColor: 'green',
                        textAlign: 'center'
                    }
                });

                const relationshipId = generateRelationshipId();
                const relationship = {
                    id: relationshipId,
                    type: 'product',
                    name: `Product ${relationshipId.slice(-6)}`,
                    result: resultNote.id,
                    sources: validItems.map(item => item.id),
                    values: values,
                    resultValue: product,
                    createdAt: Date.now()
                };

                appState.relationships.set(relationshipId, relationship);

                await resultNote.setMetadata('calculatorRelationship', relationshipId);

                await saveData();
                await updateRelationshipsUI();

                showStatus(`Product created: ${product}`, 'success');
                console.log('Product calculation created:', product);

            } catch (error) {
                console.error('Error creating product:', error);
                showStatus('Error creating product: ' + error.message, 'error');
            }
        }

        // FIXED: Expand relationship - now allows adding new elements to existing relationships
        async function expandRelationship() {
            try {
                if (appState.expandMode) {
                    // Exit expand mode
                    appState.expandMode = null;
                    await updateSelectionStatus();
                    showStatus('Exited expand mode', 'success');
                    console.log('Exited expand mode');
                    return;
                }

                console.log('Entering expand relationship mode...');

                const selection = await miro.board.getSelection();
                if (selection.length !== 1) {
                    showStatus('Select exactly one result note to expand', 'error');
                    return;
                }

                const selectedItem = selection[0];
                const relationshipId = await selectedItem.getMetadata('calculatorRelationship');

                if (!relationshipId || !appState.relationships.has(relationshipId)) {
                    showStatus('Selected note is not a calculator result', 'error');
                    return;
                }

                const relationship = appState.relationships.get(relationshipId);

                // Enter expand mode
                appState.expandMode = {
                    relationshipId: relationshipId,
                    relationshipName: relationship.name
                };

                await updateSelectionStatus();
                showStatus(`Expand mode: Select numeric sticky notes to add to ${relationship.name}`, 'success');
                console.log('Entered expand mode for relationship:', relationshipId);

            } catch (error) {
                console.error('Error in expand relationship:', error);
                showStatus('Error in expand relationship: ' + error.message, 'error');
            }
        }

        // Create resource sticky note
        async function createResource(resourceType) {
            try {
                console.log('Creating resource:', resourceType);

                const resourceValues = {
                    'barrel-small': { value: appState.globalVars.barrelSmall, name: 'Small Barrel', color: 'light_yellow' },
                    'barrel-medium': { value: appState.globalVars.barrelMedium, name: 'Med Barrel', color: 'yellow' },
                    'barrel-big': { value: appState.globalVars.barrelBig, name: 'Big Barrel', color: 'orange' },
                    'dig': { value: appState.globalVars.dig, name: 'Dig', color: 'light_green' },
                    'crate': { value: appState.globalVars.crate, name: 'Crate', color: 'light_blue' }
                };

                const resource = resourceValues[resourceType];
                if (!resource) {
                    console.warn('Unknown resource type:', resourceType);
                    return;
                }

                const viewport = await miro.board.viewport.get();
                const centerX = viewport.x + viewport.width / 2;
                const centerY = viewport.y + viewport.height / 2;

                await miro.board.createStickyNote({
                    content: `${resource.name} (${resource.value})`,
                    x: centerX + (Math.random() - 0.5) * 200,
                    y: centerY + (Math.random() - 0.5) * 200,
                    style: {
                        fillColor: resource.color,
                        textAlign: 'center'
                    }
                });

                showStatus(`${resource.name} created`, 'success');
                console.log('Resource created:', resource.name);

            } catch (error) {
                console.error('Error creating resource:', error);
                showStatus('Error creating resource: ' + error.message, 'error');
            }
        }

        // Create resource pool
        async function createResourcePool() {
            try {
                console.log('Creating resource pool...');

                const resourceTypeSelect = safeGetElement('resourceTypeSelect');
                const poolQuantityInput = safeGetElement('poolQuantity');

                if (!resourceTypeSelect || !poolQuantityInput) {
                    showStatus('Resource pool controls not found', 'error');
                    return;
                }

                const resourceType = resourceTypeSelect.value;
                const quantity = parseInt(poolQuantityInput.value) || 3;

                if (quantity < 2 || quantity > 20) {
                    showStatus('Quantity must be between 2 and 20', 'error');
                    return;
                }

                const resourceValues = {
                    'barrel-small': { value: appState.globalVars.barrelSmall, name: 'Small Barrel', color: 'light_yellow' },
                    'barrel-medium': { value: appState.globalVars.barrelMedium, name: 'Med Barrel', color: 'yellow' },
                    'barrel-big': { value: appState.globalVars.barrelBig, name: 'Big Barrel', color: 'orange' },
                    'dig': { value: appState.globalVars.dig, name: 'Dig', color: 'light_green' },
                    'crate': { value: appState.globalVars.crate, name: 'Crate', color: 'light_blue' }
                };

                const resource = resourceValues[resourceType];
                if (!resource) return;

                const viewport = await miro.board.viewport.get();
                const centerX = viewport.x + viewport.width / 2;
                const centerY = viewport.y + viewport.height / 2;

                const notes = [];
                const spacing = 120;
                const cols = Math.ceil(Math.sqrt(quantity));

                for (let i = 0; i < quantity; i++) {
                    const row = Math.floor(i / cols);
                    const col = i % cols;
                    const x = centerX + (col - (cols - 1) / 2) * spacing;
                    const y = centerY + (row - Math.floor((quantity - 1) / cols) / 2) * spacing;

                    const note = await miro.board.createStickyNote({
                        content: `${resource.name} (${resource.value})`,
                        x: x,
                        y: y,
                        style: {
                            fillColor: resource.color,
                            textAlign: 'center'
                        }
                    });

                    notes.push(note);
                }

                for (let i = 0; i < notes.length - 1; i++) {
                    await miro.board.createConnector({
                        start: { item: notes[i].id },
                        end: { item: notes[i + 1].id },
                        style: { strokeColor: 'gray' }
                    });
                }

                showStatus(`Resource pool of ${quantity} ${resource.name}s created`, 'success');
                console.log('Resource pool created:', quantity, resource.name);

            } catch (error) {
                console.error('Error creating resource pool:', error);
                showStatus('Error creating resource pool: ' + error.message, 'error');
            }
        }

        // Spawn connected numbers
        async function spawnNumbers() {
            try {
                console.log('Spawning connected numbers...');

                const spawnCountInput = safeGetElement('spawnCount');
                if (!spawnCountInput) {
                    showStatus('Spawn count input not found', 'error');
                    return;
                }

                const count = parseInt(spawnCountInput.value) || 3;

                if (count < 1 || count > 20) {
                    showStatus('Count must be between 1 and 20', 'error');
                    return;
                }

                const viewport = await miro.board.viewport.get();
                const centerX = viewport.x + viewport.width / 2;
                const centerY = viewport.y + viewport.height / 2;

                const notes = [];
                const spacing = 100;

                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * 2 * Math.PI;
                    const x = centerX + Math.cos(angle) * spacing;
                    const y = centerY + Math.sin(angle) * spacing;

                    const note = await miro.board.createStickyNote({
                        content: (i + 1).toString(),
                        x: x,
                        y: y,
                        style: {
                            fillColor: 'gray',
                            textAlign: 'center'
                        }
                    });

                    notes.push(note);
                }

                for (let i = 0; i < notes.length; i++) {
                    const nextIndex = (i + 1) % notes.length;
                    await miro.board.createConnector({
                        start: { item: notes[i].id },
                        end: { item: notes[nextIndex].id },
                        style: { strokeColor: 'gray' }
                    });
                }

                showStatus(`${count} connected numbers spawned`, 'success');
                console.log('Connected numbers spawned:', count);

            } catch (error) {
                console.error('Error spawning numbers:', error);
                showStatus('Error spawning numbers: ' + error.message, 'error');
            }
        }

        // Toggle relationships panel visibility
        function toggleRelationships() {
            appState.isRelationshipsVisible = !appState.isRelationshipsVisible;
            const relationshipsList = safeGetElement('relationshipsList');
            const toggleBtn = safeGetElement('toggleRelationships');

            if (relationshipsList && toggleBtn) {
                if (appState.isRelationshipsVisible) {
                    relationshipsList.style.display = 'block';
                    toggleBtn.textContent = toggleBtn.textContent.replace('▼', '▲');
                } else {
                    relationshipsList.style.display = 'none';
                    toggleBtn.textContent = toggleBtn.textContent.replace('▲', '▼');
                }
            }

            console.log('Toggled relationships visibility:', appState.isRelationshipsVisible);
        }

        // Update relationships UI
        async function updateRelationshipsUI() {
            const count = appState.relationships.size;

            const countElement = safeGetElement('relationshipCount');
            if (countElement) {
                countElement.textContent = count;
            } else {
                console.warn('relationshipCount element not found, but continuing...');
            }

            const content = safeGetElement('relationshipsContent');
            if (!content) {
                console.warn('relationshipsContent element not found');
                return;
            }

            if (count === 0) {
                content.innerHTML = 'No calculator relationships found';
                return;
            }

            const relationships = Array.from(appState.relationships.values())
                .sort((a, b) => b.createdAt - a.createdAt);

            content.innerHTML = relationships.map(rel => `
        <div class="relationship-item ${rel.type}">
            <div class="relationship-header" onclick="gotoRelationship('${rel.id}')">
                <span>${rel.type === 'sum' ? 'Sum' : 'Product'}: ${rel.resultValue}</span>
                <span class="relationship-name" onclick="event.stopPropagation(); renameRelationship('${rel.id}')">${rel.name}</span>
            </div>
            <div class="relationship-sources">Sources: ${rel.values.join(' + ')} (${rel.sources.length} items)</div>
            <div class="relationship-actions">
                <button class="action-btn goto-btn" onclick="gotoRelationship('${rel.id}')">Go To</button>
                <button class="action-btn select-parents-btn" onclick="selectParents('${rel.id}')">Select Parents</button>
                <button class="action-btn rename-btn" onclick="renameRelationship('${rel.id}')">Rename</button>
                <button class="action-btn delete-btn" onclick="deleteRelationship('${rel.id}')">Delete</button>
            </div>
        </div>
    `).join('');

            console.log('Updated relationships UI:', count, 'relationships');
        }

        // Go to relationship items
        async function gotoRelationship(relationshipId) {
            try {
                const relationship = appState.relationships.get(relationshipId);
                if (!relationship) return;

                const allIds = [...relationship.sources, relationship.result];
                const items = [];

                for (const id of allIds) {
                    try {
                        const item = await miro.board.getById(id);
                        items.push(item);
                    } catch (e) {
                        console.log('Item not found:', id);
                    }
                }

                if (items.length > 0) {
                    await miro.board.select({ id: items.map(item => item.id) });
                    await miro.board.viewport.zoomTo(items);
                }

            } catch (error) {
                console.error('Error going to relationship:', error);
                showStatus('Error navigating to relationship', 'error');
            }
        }

        // Select parent items only
        async function selectParents(relationshipId) {
            try {
                const relationship = appState.relationships.get(relationshipId);
                if (!relationship) return;

                const items = [];
                for (const id of relationship.sources) {
                    try {
                        const item = await miro.board.getById(id);
                        items.push(item);
                    } catch (e) {
                        console.log('Item not found:', id);
                    }
                }

                if (items.length > 0) {
                    await miro.board.select({ id: items.map(item => item.id) });
                    await miro.board.viewport.zoomTo(items);
                }

            } catch (error) {
                console.error('Error selecting parents:', error);
                showStatus('Error selecting parent items', 'error');
            }
        }

        // Rename relationship
        let currentRenameId = null;

        function renameRelationship(relationshipId) {
            const relationship = appState.relationships.get(relationshipId);
            if (!relationship) return;

            currentRenameId = relationshipId;
            const renameInput = safeGetElement('renameInput');
            const modal = safeGetElement('renameModal');

            if (renameInput && modal) {
                renameInput.value = relationship.name;
                modal.style.display = 'block';
                renameInput.focus();
            }

            console.log('Renaming relationship:', relationshipId);
        }

        async function confirmRename() {
            if (!currentRenameId) return;

            const renameInput = safeGetElement('renameInput');
            if (!renameInput) return;

            const newName = renameInput.value.trim();
            if (!newName) {
                showStatus('Name cannot be empty', 'error');
                return;
            }

            const relationship = appState.relationships.get(currentRenameId);
            if (relationship) {
                relationship.name = newName;
                await saveData();
                await updateRelationshipsUI();
                showStatus('Relationship renamed', 'success');
                console.log('Relationship renamed:', newName);
            }

            cancelRename();
        }

        function cancelRename() {
            currentRenameId = null;
            const modal = safeGetElement('renameModal');
            const input = safeGetElement('renameInput');

            if (modal) modal.style.display = 'none';
            if (input) input.value = '';

            console.log('Rename cancelled');
        }

        // Delete relationship - deletes all sticky notes and clears metadata
        async function deleteRelationship(relationshipId) {
            try {
                const relationship = appState.relationships.get(relationshipId);
                if (!relationship) return;

                if (!confirm(`Delete relationship "${relationship.name}" and all its sticky notes?`)) return;

                if (appState.updateThrottles.has(relationshipId)) {
                    clearTimeout(appState.updateThrottles.get(relationshipId));
                    appState.updateThrottles.delete(relationshipId);
                }

                const itemsToDelete = [...relationship.sources, relationship.result];
                const deletedItems = [];

                for (const itemId of itemsToDelete) {
                    try {
                        const item = await miro.board.getById(itemId);

                        const metadata = await item.getMetadata('calculatorRelationship');
                        if (metadata) {
                            await item.setMetadata('calculatorRelationship', null);
                        }

                        await item.remove();
                        deletedItems.push(itemId);
                        console.log('Deleted sticky note:', itemId);

                    } catch (e) {
                        console.log('Item not found or already deleted:', itemId);
                    }
                }

                appState.relationships.delete(relationshipId);

                await saveData();
                await updateRelationshipsUI();
                showStatus(`Relationship deleted - removed ${deletedItems.length} sticky notes`, 'success');
                console.log('Relationship deleted:', relationshipId, 'Items deleted:', deletedItems.length);

            } catch (error) {
                console.error('Error deleting relationship:', error);
                showStatus('Error deleting relationship', 'error');
            }
        }

        // Utility functions
        function generateRelationshipId() {
            return `rel_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        }

        async function cleanupRelationshipsForItem(itemId) {
            const toDelete = [];

            for (const [id, relationship] of appState.relationships) {
                if (relationship.sources.includes(itemId) || relationship.result === itemId) {
                    toDelete.push(id);
                }
            }

            for (const id of toDelete) {
                if (appState.updateThrottles.has(id)) {
                    clearTimeout(appState.updateThrottles.get(id));
                    appState.updateThrottles.delete(id);
                }

                appState.relationships.delete(id);
                console.log('Cleaned up relationship:', id);
            }
        }

        // Show status message
        function showStatus(message, type = 'success') {
            const statusDiv = safeGetElement('status');
            if (!statusDiv) return;

            statusDiv.textContent = message;
            statusDiv.className = type;
            statusDiv.style.display = 'block';

            const timeoutId = setTimeout(() => {
                if (statusDiv) {
                    statusDiv.style.display = 'none';
                }
            }, 3000);

            appState.timeouts.add(timeoutId);

            console.log(`Status [${type}]:`, message);
        }

        // Handle keyboard events
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && currentRenameId &&
                safeGetElement('renameModal') &&
                safeGetElement('renameModal').style.display === 'block') {
                e.preventDefault();
                confirmRename();
            }

            if (e.key === 'Escape' && currentRenameId) {
                e.preventDefault();
                cancelRename();
            }

            // Exit expand mode with Escape key
            if (e.key === 'Escape' && appState.expandMode) {
                expandRelationship(); // This will exit expand mode
            }
        });

        // Make functions globally accessible for onclick handlers in HTML
        window.gotoRelationship = gotoRelationship;
        window.selectParents = selectParents;
        window.renameRelationship = renameRelationship;
        window.deleteRelationship = deleteRelationship;
        window.forceUpdateAllRelationships = forceUpdateAllRelationships;

        // Data validation and cleanup
        async function validateAndCleanData() {
            const toDelete = [];

            for (const [id, relationship] of appState.relationships) {
                let isValid = true;

                try {
                    await miro.board.getById(relationship.result);
                } catch (e) {
                    isValid = false;
                }

                for (const sourceId of relationship.sources) {
                    try {
                        await miro.board.getById(sourceId);
                    } catch (e) {
                        isValid = false;
                        break;
                    }
                }

                if (!isValid) {
                    toDelete.push(id);
                }
            }

            for (const id of toDelete) {
                appState.relationships.delete(id);
            }

            if (toDelete.length > 0) {
                await saveData();
                await updateRelationshipsUI();
                showStatus(`Cleaned up ${toDelete.length} invalid relationship(s)`, 'success');
                console.log('Data validation completed:', toDelete.length, 'invalid relationships removed');
            }
        }

        // Initialize the app
        async function initializeApp() {
            if (appState.initialized) {
                console.log('App already initialized, skipping...');
                return;
            }

            try {
                console.log('Initializing Miro Resource Calculator...');

                await waitForDOM();
                console.log('DOM ready');

                const criticalElements = [
                    'barrelSmall', 'barrelMedium', 'barrelBig', 'digValue', 'crateValue',
                    'sumBtn', 'productBtn', 'expandBtn', 'selection'
                ];

                let missingElements = [];
                for (const elementId of criticalElements) {
                    if (!document.getElementById(elementId)) {
                        missingElements.push(elementId);
                    }
                }

                if (missingElements.length > 0) {
                    throw new Error(`Missing critical DOM elements: ${missingElements.join(', ')}`);
                }
                console.log('All critical DOM elements found');

                await loadPersistedData();
                setupEventHandlers();
                await setupMiroEventListeners();
                updateGlobalVariablesUI();
                await updateSelectionStatus();
                await updateRelationshipsUI();

                const validationInterval = setInterval(validateAndCleanData, 30000);
                appState.intervals.add(validationInterval);
                console.log('Started periodic data validation (30s interval)');

                appState.initialized = true;

                console.log('Miro Resource Calculator initialized successfully!');
                showStatus('App initialized successfully', 'success');

            } catch (error) {
                console.error('Failed to initialize app:', error);
                showStatus('Failed to initialize app: ' + error.message, 'error');
                throw error;
            }
        }

        // Error handling for unhandled promises
        window.addEventListener('unhandledrejection', (event) => {
            console.error('Unhandled promise rejection:', event.reason);
            showStatus('An unexpected error occurred', 'error');
        });

        // Cleanup when page unloads
        window.addEventListener('beforeunload', () => {
            console.log('Cleaning up before page unload...');
            cleanupMemory();
        });

        // Cleanup when app is hidden/paused
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                console.log('App hidden, cleaning up throttles...');
                cleanupThrottles();
            }
        });

        // Start the app
        async function startApp() {
            try {
                console.log('Starting Miro Resource Calculator App...');
                console.log('App Version:', APP_VERSION);
                console.log('Deployment ID:', DEPLOYMENT_ID);

                await waitForDOM();
                console.log('DOM ready for initialization');

                if (!window.miro) {
                    throw new Error('Miro SDK not available - make sure the SDK script is loaded');
                }
                console.log('Miro SDK detected');

                await initializeApp();

                console.log('App started successfully!');

            } catch (error) {
                console.error('Failed to start app:', error);

                const statusDiv = document.getElementById('status');
                if (statusDiv) {
                    statusDiv.textContent = 'Failed to start app: ' + error.message;
                    statusDiv.className = 'error';
                    statusDiv.style.display = 'block';
                }

                alert('Failed to start app: ' + error.message);

                console.error('Error details:', {
                    message: error.message,
                    stack: error.stack,
                    timestamp: new Date().toISOString(),
                    deploymentId: DEPLOYMENT_ID
                });
            }
        }

        // Start the app immediately
        startApp();

    </script>
</body>
</html>
